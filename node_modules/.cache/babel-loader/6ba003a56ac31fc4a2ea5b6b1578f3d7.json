{"ast":null,"code":"var _slicedToArray = require(\"/Users/erinwang/my-test-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _objectSpread = require(\"/Users/erinwang/my-test-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar client = https;\nvar options = {\n  default: {\n    headers: {\n      'Content-Type': 'application/json',\n      'User-Agent': 'SoundOfTextClient'\n    },\n    hostname: 'api.soundoftext.com'\n  },\n  request: function request() {\n    return _objectSpread({}, options.default, {\n      method: 'POST',\n      path: '/sounds'\n    });\n  },\n  status: function status(id) {\n    return _objectSpread({}, options.default, {\n      method: 'GET',\n      path: \"/sounds/\".concat(id)\n    });\n  }\n};\nvar bodies = {\n  request: function request(_ref) {\n    var _ref$engine = _ref.engine,\n        engine = _ref$engine === void 0 ? 'Google' : _ref$engine,\n        text = _ref.text,\n        voice = _ref.voice;\n    return JSON.stringify({\n      engine: engine,\n      data: {\n        text: text,\n        voice: voice\n      }\n    });\n  }\n};\n\nvar configure = function configure(_ref2) {\n  var api = _ref2.api;\n\n  var _api$split = api.split('://'),\n      _api$split2 = _slicedToArray(_api$split, 2),\n      protocol = _api$split2[0],\n      hostname = _api$split2[1];\n\n  options = _objectSpread({}, options, {\n    default: _objectSpread({}, options.default, {\n      hostname: hostname\n    })\n  });\n  client = protocol == 'https' ? https : http;\n};\n\nvar _request = function request(options, body) {\n  return new Promise(function (resolve, reject) {\n    var request = client.request(options, function (res) {\n      var data = '';\n      res.on('data', function (chunk) {\n        return data = data + chunk;\n      });\n      res.on('end', function () {\n        var response = JSON.parse(data);\n        if (response.message) reject(response.message);else resolve(response);\n      });\n    });\n    request.setTimeout(10 * 1000);\n    if (body) request.write(body);\n    request.on('error', reject);\n    request.end();\n  });\n};\n\nvar retry = function retry(func, timeout) {\n  return new Promise(function (resolve) {\n    return setTimeout(function () {\n      return resolve(func());\n    }, timeout);\n  });\n};\n\nvar location = function location(_ref3) {\n  var id = _ref3.id,\n      _ref3$timeout = _ref3.timeout,\n      timeout = _ref3$timeout === void 0 ? 1000 : _ref3$timeout;\n  return operations.status({\n    id: id\n  }).then(function (res) {\n    if (res.status == 'Error') throw res.message;\n    if (res.status == 'Done') return res.location;\n    if (timeout > 30 * 1000) throw 'Operation timed out';\n    return retry(function () {\n      return location({\n        id: id,\n        timeout: timeout * 2\n      });\n    }, timeout);\n  });\n};\n\nvar create = function create(request) {\n  return operations.request(request).then(operations.location);\n};\n\nvar operations = {\n  create: create,\n  location: location,\n  request: function request(_ref4) {\n    var text = _ref4.text,\n        voice = _ref4.voice;\n    return _request(options.request(), bodies.request({\n      text: text,\n      voice: voice\n    }));\n  },\n  status: function status(_ref5) {\n    var id = _ref5.id;\n    return _request(options.status(id));\n  }\n};\nmodule.exports = {\n  configure: configure,\n  sounds: operations\n};","map":null,"metadata":{},"sourceType":"script"}